# Express + Scalekit Passwordless Auth (Minimal)

Small, browseable Express.js sample showing core passwordless flows with **Scalekit**. Kept intentionally lean: few files, clear steps, minimal options.

## What’s Included

- Scalekit client lazy init (`config/scalekit.js`).
- Passwordless email endpoints: send, resend, verify by code, verify by magic link.
- Minimal middleware: security (helmet+compression), CORS, sessions, rate limits, logging.
- Central validation + error handler.
- Swagger UI (`/docs`) served from a pre-generated OpenAPI spec.
- Docker + compose examples (Redis placeholder not yet wired in code).
- JWT issued on verification (remove if not needed).

## Quick Start

1. Install dependencies

  ```sh
  npm install
  ```

1. Create `.env` (see vars below) with your Scalekit credentials.

1. Run in dev (auto regenerates spec):

  ```sh
  npm run dev
  ```

1. Open Swagger UI: <http://localhost:3000/docs>

1. Send an email → verify via code or magic link.

## Environment Variables

Required:

- `SCALEKIT_ENVIRONMENT_URL`
- `SCALEKIT_CLIENT_ID`
- `SCALEKIT_CLIENT_SECRET`
- `JWT_SECRET` (remove JWT logic if you don’t need it)
- `JWT_SECRET` (remove JWT logic if you don’t need it)
- `JWT_ENABLED` (true/false, default true) – toggle JWT issuance

Optional:

- `SESSION_SECRET` (auto-generated outside production if missing)
- `NEXT_PUBLIC_BASE_URL` (for building magic link redirect; falls back to `http://localhost:<PORT>`)
- `CORS_ALLOWED_ORIGINS` (CSV)
- `PASSWORDLESS_MAGICLINK_URI_OVERRIDE` (force a redirect URI)
- `LOG_FORMAT` (`text` | `json`)
- `LOG_LEVEL` (`info` | `error`)

If `SESSION_SECRET` is omitted in dev/test an ephemeral one is logged (never do this in production).

## Passwordless Flow

1. POST `/api/auth/passwordless/email/send` with `{ email }`.
2. Email arrives (OTP and/or link — configured in Scalekit dashboard). Automatic retry adds `magiclinkAuthUri` if SDK requires it.
3. OTP path: POST `/api/auth/passwordless/email/verify/code` with `code` + `authRequestId`.
4. Magic link path: browser hits `/api/auth/passwordless/verify?link_token=...&auth_request_id=...` (fallback retry if auth request id expired).
5. Server sets `req.session.user` and returns `{ user, token }`.
6. Client optionally calls `/api/me` to fetch session user; `/api/auth/logout` to end session.

## Endpoints At A Glance

| Method | Path | Purpose |
|--------|------|---------|
| POST | `/api/auth/passwordless/email/send` | Dispatch passwordless email |
| POST | `/api/auth/passwordless/email/resend` | Resend email by `authRequestId` |
| POST | `/api/auth/passwordless/email/verify/code` | Verify OTP code |
| GET  | `/api/auth/passwordless/verify` | Verify magic link |
| GET  | `/api/me` | Current session user |
| POST | `/api/auth/logout` | Destroy session |
| GET  | `/api/health` | Health check |

Root `/` also returns a small JSON index.

## Folder Structure (Slim)

```text
src/
  app.js          Express app wiring (loads pre-generated spec)
  server.js       Starts HTTP server (spec generated by prestart script)
  config/         Env + Scalekit client
  middleware/     security | cors | session | rateLimits
  routes/         auth | health (/me + /health)
  services/       Thin auth service wrappers
  utils/          logger + errors
  docs/           openapi.json + generator script
```




## Session & User Handling

After Scalekit passwordless verification, the backend upserts the user profile in Supabase using the service role key. No Supabase Auth verification is required. Session is stored in Express (in-memory for demo, Redis recommended for production).



## Security Notes

- Use Redis for session store in production (see `docker-compose.yml`).
- Store secrets securely and never expose service role keys to the client.
- Tighten CORS (`CORS_ALLOWED_ORIGINS`).
- Add CSP, CSRF (if browser forms), audit logging as needed.


## Docker

Production image runs `npm start` (prestart generates OpenAPI spec automatically):

```sh
docker build -t scalekit-passwordless .
docker run --env-file .env -p 3000:3000 scalekit-passwordless
```

Compose (adds Redis; sessions use it automatically if `REDIS_URL` is set):

```sh
docker compose up --build
```

To enable Redis session store set in `.env` (compose supplies hostname):

```env
REDIS_URL=redis://redis:6379/0
```

For live reload in a container, bind mount and override command:

```sh
docker compose run --service-ports app npm run dev
```

## Rate Limiting

- Global limiter (window / max configurable via env).
- Send limiter (per email, default 2/min) on the send endpoint.

## Testing via Swagger

1. Open `/docs`.
2. Execute send endpoint with email.
3. Resend if desired.
4. Verify with code OR follow magic link.



## Backup Strategies (Supabase)

- Use Supabase's built-in automated backups (see Supabase project settings > Backups).
- For manual backups, use the Supabase CLI:

```sh
supabase db dump --file backup.sql
```

- You can also export data from the dashboard or automate with scheduled jobs.


## Next Steps / Ideas

- Add Redis session store for scalability.
- Add structured logging and tracing.
- Add ESLint and tests for code quality.

## Design Rationale (Experienced Dev Quick Notes)

- Lazy Scalekit init: defers network/auth cost until first auth call; keeps startup fast & avoids failing boot if temporarily misconfigured during setup.
- Service layer: isolates SDK calls so route handlers stay thin; swapping storage or extending logic is localized.
- In-memory authRequests: sufficient for demo; a real deploy should persist (Redis/DB) if you need resend auditing or multi-instance scaling.
- Conditional JWT: many apps only need a cookie session; `JWT_ENABLED` flag allows turning token off without code edits.
- Express-session memory store: simplest for illustration; explicit README warning steers production users to Redis.
- Rate limiting with express-rate-limit: avoids custom logic; separate limiter for send endpoint to protect email channel specifically.
- Automatic magic link URI injection: removes mandatory client param friction; only retries when SDK demands it to stay minimal.
- Swagger UI + static spec: lowers barrier for trying endpoints quickly; pre-generation prevents dev hot reload loops.
- Minimal env schema via Joi: immediate, aggregated validation errors; auto-generated dev `SESSION_SECRET` accelerates cloning & running.
- Morgan-based logger with pluggable format: no heavy logging dependency; easy pivot later to pino/winston.

- No custom auth guard middleware retained: simple inline session checks keep cognitive load low given tiny surface.
